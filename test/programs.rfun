---------------------------------------------------------------
---- BASIC
---------------------------------------------------------------

-- swap :: a * b -> b * a
swap {x,y} =^= {y,x}

id x =^= x

-- It is possible to diverge
rec x =^= 
		let x' = rec x
		in x'

-- |Implemententation of |.| as a function
dupEq v =^=
		case |v| of
				v' -> v'

---------------------------------------------------------------
---- ARITHMETIC
---------------------------------------------------------------

--data N = Z | S(n)

-- even :: N -> Either N N
even_ Z =^= Right(Z)
even_ S(Z) =^= Left(S(Z))
even_ S(S(x)) =^= 
		let x' = even_ x
		in  case x' of
						Right(x'') -> Right (S(S(x'')))
						Left(x'')  -> Left (S(S(x'')))

-- even :: N -> N
--   only defined for even numbers
even Z =^= Z
even S(S(x)) =^= 
		let x' = even x
		in  S(S(x'))

-- odd :: N -> N
--   only defined for odd numbers
odd S(Z) =^= S(Z)
odd S(S(x)) =^= 
		let x' = odd x
		in  S(S(x'))

inc Z =^= S(Z)
inc S(np) =^= 
		let npp = inc np 
		in  S(npp)

plus {x,  Z } =^= |{x}|
plus {x,S(u)} =^= 
    let {xp,up} = plus {x,u} 
    in  {xp, S(up)}

minus xy =^=
		rlet xy = plus xy'
		in   xy'

-- fib :: N -> N * N
fib Z    =^= {S(Z),S(Z)}
fib S(m) =^= 
		let {x,y} = fib m 
		in plus {y,x}

mult {x,     Z  } =^= {x, Z}
mult {x,   S(Z) } =^= |{x}|
mult {x, S(S(y))} =^=
		let {x', m} = mult {x, S(y)}
		in  plus {x', m}


divide xy =^=
		rlet xy = mult xy'
		in   xy'

compare {Z   ,   Z } =^= EQ(Z)
compare {Z   , S(b)} =^= LT(Z,S(b))
compare {S(a),   Z } =^= GT(S(a),Z)
compare {S(a), S(b)} =^= 
		let c = compare {a,b}
		in case c of
				EQ(a)    -> EQ(S(a))
				LT(a, b) -> LT(S(a), S(b))
				GT(a, b) -> GT(S(a), S(b))

less {  Z , S(b)} =^= {Z, S(b)}
less {S(a), S(b)} =^= 
		let {a', b'} = less {a, b}
		in  {S(a'), S(b')}

neq {  Z , S(b)} =^= {Z, S(b)}
neq {S(a),   Z } =^= {S(a), Z}
neq {S(a), S(b)} =^= 
		let {a', b'} = neq {a, b}
		in  {S(a'), S(b')}

eq {a,b} =^=
		case |{a,b}| of
				{x} -> x

---------------------------------------------------------------
---- LIST TRANSFORMATION
---------------------------------------------------------------

-- |Zip
zip {[],[]} =^= []
zip {(x:xs),(y:ys)} =^=
	let zs = zip {xs, ys}
	in  ({x,y}:zs)

-- |Unzip
unzip v =^= rlet v = zip v' in v'

-- scanr specialized to plus
scanr {i, []}     =^= {i, []}
scanr {i, (x:xs)} =^= 
	  let {i', x'} = plus {i, x}
	      {x'', l} = scanr {x', xs}
	  in  {i', (x'' : l)}

scanr1 [] =^= []
scanr1 (x:xs) =^= scanr {x,xs}

-- scanl specialized to plus
scanl {i, []}      =^= {i, []}
scanl {i, [x]}     =^= 
		let {i', x'} = plus {i, x}
		in  {i', [x']}
scanl {i, (x : z : xs)} =^= 
		let {i', (y:ys)} = scanl {i, (z : xs)}
		    {y', x'} = plus {y, x}
		in  {i', (x' : y' : ys)}

-- foldr specialised to plus
--   returns the list untouched
foldr {x,[]} =^= {x,[]}
foldr {x,(y:ys)} =^= 
	let {y',x'} = plus {y,x}
	    {x'',ys'} = foldr {x',ys}
	in  {x'', (y':ys')}

foldr1 (x:xs) =^=
	let {x',x''} = dupEq {x} 
	    {y, xs'} = foldr {x',xs}
	in  {y,(x'':xs')}


-- foldl specialised to plus
--   returns the list untouched
foldl {x,[]} =^= {x,[]}
foldl {x,(y:ys)} =^= 
	let {x',ys'} = foldr {x,ys}
      {y',x''} = plus {y,x'}
	in  {x'', (y':ys')}


-- map specialized to inc
map      []  =^= []
map (x : xs) =^= 
		let x' = inc x
		    xs' = map xs
		in  (x' : xs')


reverse xs =^= 
		let  {xs_s, xs'}     = length xs
		     {[], ys, xs_s'} = move {xs', [], xs_s} 
		rlet {xs_s', ys}     = length ys'
		in   ys'

-- This function in only partial
--  helper to reverse
move {      x , l,   Z } =^= {x, l, Z}
move {(x : xs), l, S(s)} =^= 
		let {ys, ls, s'} = move {xs,(x:l),s} 
		in  {ys, ls, S(s')}

-- splitAt is identical to the Haskell version
splitAt {  Z ,       l } =^= {[],l}
splitAt {S(s), (l : ls)} =^=
		let {l1, l2} = splitAt {s, ls}
		in  {(l : l1), l2}

-- Finds the head and tail
hdtl (x:xs) =^= {x,xs}

-- Finds the last elements and the rest of the list
last ([x])  =^= {[],x}
last (x:xs) =^= 
	let {xs',l} = last xs
	in  {(x:xs'),l} 


-- If it is called reverse and the N is not equal
--   to the length of the list, I will fail.
length [] =^= {Z,[]}
length (x : xs) =^=
		let {l, xs'} = length xs
		in  {S(l), (x : xs')}

-- append function
append {[],l}      =^= {[], l}
append {(x : xs), l} =^=  
		let {xs', l'} = append {xs, l}
		in  case |{x}| of
				{x', x''} -> {(x' : xs'), (x'' : l')} 

-- The reverse of the append
unAppend x =^=
		rlet x = append x'
		in x'

-- Identical to Haskell replicate function
replicate {S(Z),x} =^= [x]
replicate {S(n),x} =^=
	let {x',x''} = dupEq {x}
	    xs = replicate {n,x'}
	in  (x'':xs)

-- Similar to Haskell intersperse function
intersperse {x,[]}       =^= {x,[]}
intersperse {x,[y]}      =^= {x,[y]}
intersperse {x,(l:list)} =^= 
	let {x',list'} = intersperse {x,list}
	    {x'',xn} = dupEq {x'}
	in  {x'',(l:xn:list')}

-- Identical to Haskell transpose function
transpose []     =^= []
transpose (x:xs) =^=
	let xs' = transpose xs
	in  addToLists {x,xs'}

-- Helper function for transpose
--   Adds empty lists this second input is an empty list, e.g. addToLists {[1,2],[]} = [[1],[2]]
addToLists {[],[]} =^= []
addToLists {(x:xs),[]} =^=
	let ys' = addToLists {xs, []}
	in  (([x]):ys')
addToLists {(x:xs),(y:ys)} =^=
	let ys' = addToLists {xs, ys}
	in  ((x:y):ys')

-- Identical to Haskell subsequences function
subsequences [] =^= [[]]
subsequences (x:xs) =^=
	let xs' = subsequences xs
	in  duplicateAdd {x,xs'}

-- Helper function for subsequences
duplicateAdd {x,[y]} =^= 
	let {y',y''} = dupEq {y}
	in  [y',(x:y'')]
duplicateAdd {x,(y:ys)} =^= 
	let {x',x''} = dupEq {x}
			ys' = duplicateAdd{x',ys}
	    {y',y''} = dupEq {y}
	in  (y':(x'':y''):ys')





--permutations [] =^= []
--permutations [x] =^= [[x]]
--permutations (x:xs) =^=
--	let ys = permutations xs

-- 

--interleave {x,ys} =^= 
--	let (y:ysub) = subLists ys
--			{x',x''} = dupEq {x}
--			{ysub,}
--			consToLists {x',ys'}
	    


subLists [] =^= [[]]
subLists (x:xs) =^=
	let {xs',xs''} = dupEq {xs}
	    ys = subLists xs'
	in  ((x:xs''):ys)

consToLists {x,ys} =^=
	let {x',((x'':y):ys')} = consToLists_h {x,ys}
	    {x} = dupEq {x',x''}
	in  ((x:y):ys')

consToLists_h {x,[]} =^= {x,[]}
consToLists_h {x, (y:ys)} =^=
	let {x',x''} = dupEq {x}
	    {x''',ys'} = consToLists_h {x',ys}
	in  {x''',((x'':y):ys')}


---------------------------------------------------------------
---- APPLICATIONS
---------------------------------------------------------------

-- pack :: Eq a => [a] -> [a * N]
pack [] =^= []
pack (c1 : r) =^=
	case pack r of
			[] -> ([{c1, S(Z)}])
			({c2, n} : t) ->
					case |{c1,c2}| of
							{c1p, c2p} -> ({c1p, S(Z)} : ({c2p, n} : t))
							{c} -> ({c, S(n)} : t)

unpack l =^= 
	rlet l = pack l'
	in l'
