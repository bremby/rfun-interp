---------------------------------------------------------------
---- BASIC
---------------------------------------------------------------

-- swap :: a * b -> b * a
swap {x,y} =^= {y,x}

id x =^= x

-- It is possible to diverge
rec x =^= 
		let x' = rec x
		in x'

-- |Implemententation of |.| as a function
dupEq v =^=
		case |v| of
				v' -> v'

---------------------------------------------------------------
---- ARITHMETIC
---------------------------------------------------------------

--data N = Z | S(n)

-- even :: N -> Either N N
even_ Z =^= Right(Z)
even_ S(Z) =^= Left(S(Z))
even_ S(S(x)) =^= 
		let x' = even_ x
		in  case x' of
						Right(x'') -> Right (S(S(x'')))
						Left(x'')  -> Left (S(S(x'')))

-- even :: N -> N
--   only defined for even numbers
even Z =^= Z
even S(S(x)) =^= 
		let x' = even x
		in  S(S(x'))

-- odd :: N -> N
--   only defined for odd numbers
odd S(Z) =^= S(Z)
odd S(S(x)) =^= 
		let x' = odd x
		in  S(S(x'))

inc Z =^= S(Z)
inc S(np) =^= 
		let npp = inc np 
		in  S(npp)

--plus :: Nat -> Nat <-> Nat
plus {x,  Z } =^= |{x}|
plus {x,S(u)} =^= 
    let {xp,up} = plus {x,u} 
    in  {xp, S(up)}

minus xy =^=
		rlet xy = plus xy'
		in   xy'

-- fib :: N -> N * N
fib Z    =^= {S(Z),S(Z)}
fib S(m) =^= 
		let {x,y} = fib m 
		in plus {y,x}

mult {x,     Z  } =^= {x, Z}
mult {x,   S(Z) } =^= |{x}|
mult {x, S(S(y))} =^=
		let {x', m} = mult {x, S(y)}
		in  plus {x', m}


divide xy =^=
		rlet xy = mult xy'
		in   xy'


-- This square root function is very simple and basically iterates 
-- over all possible integers. Function will fail if the input 
-- is not the square of an integer.
sqrt s =^=
	let {i,sq} = sqrt_h {1,1,s}
      {sq'} = dupEq {S(i),sq}
  in  sq'

sqrt_h {n,m,s} =^=
	case |{m,s}| of
		{m',s'} ->
			let {m'',s''} = less {m',s'}
			    {n',m'''} = plus {n,m''}
			    {n'',m4} = plus {S(n'),m'''}
			    {i,sq} = sqrt_h {n'',m4,s''}
			in  {S(i),sq}
		{s'} -> 
			let {n',n''} = divide {n,s'}
			    {n'''} = dupEq {n',n''} 
			in {Z,n'''}

square x =^= rlet x = sqrt x' in x'

compare {Z   ,   Z } =^= EQ(Z)
compare {Z   , S(b)} =^= LT(Z,S(b))
compare {S(a),   Z } =^= GT(S(a),Z)
compare {S(a), S(b)} =^= 
		let c = compare {a,b}
		in case c of
				EQ(a)    -> EQ(S(a))
				LT(a, b) -> LT(S(a), S(b))
				GT(a, b) -> GT(S(a), S(b))

less {  Z , S(b)} =^= {Z, S(b)}
less {S(a), S(b)} =^= 
		let {a', b'} = less {a, b}
		in  {S(a'), S(b')}

neq {  Z , S(b)} =^= {Z, S(b)}
neq {S(a),   Z } =^= {S(a), Z}
neq {S(a), S(b)} =^= 
		let {a', b'} = neq {a, b}
		in  {S(a'), S(b')}

eq {a,b} =^=
		case |{a,b}| of
				{x} -> x

---------------------------------------------------------------
---- LIST TRANSFORMATION
---------------------------------------------------------------

-- |Zip
zip {[],[]} =^= []
zip {(x:xs),(y:ys)} =^=
	let zs = zip {xs, ys}
	in  ({x,y}:zs)

-- |Unzip
unzip v =^= rlet v = zip v' in v'

-- scanr specialized to plus
scanr {i, []}     =^= {i, []}
scanr {i, (x:xs)} =^= 
	  let {i', x'} = plus {i, x}
	      {x'', l} = scanr {x', xs}
	  in  {i', (x'' : l)}

scanr1 [] =^= []
scanr1 (x:xs) =^= scanr {x,xs}

-- scanl specialized to plus
scanl {i, []}      =^= {i, []}
scanl {i, [x]}     =^= 
		let {i', x'} = plus {i, x}
		in  {i', [x']}
scanl {i, (x : z : xs)} =^= 
		let {i', (y:ys)} = scanl {i, (z : xs)}
		    {y', x'} = plus {y, x}
		in  {i', (x' : y' : ys)}

-- foldr specialised to plus
--   this is actually more similar to mapAccumR
foldr {x,[]} =^= {x,[]}
foldr {x,(y:ys)} =^= 
	let {y',x'} = plus {y,x}
	    {x'',ys'} = foldr {x',ys}
	in  {x'', (y':ys')}

foldr1 (x:xs) =^=
	let {x',x''} = dupEq {x} 
	    {y, xs'} = foldr {x',xs}
	in  {y,(x'':xs')}


-- foldl specialised to plus
--   this is actually more similar to mapAccumL
foldl {x,[]} =^= {x,[]}
foldl {x,(y:ys)} =^= 
	let {x',ys'} = foldl {x,ys}
      {y',x''} = plus {y,x'}
	in  {x'', (y':ys')}

foldl1 [x] =^= 
	let {x',x''} = dupEq {x}
	in  {x',[x'']}
foldl1 (y:ys) =^= 
	let {x,ys'} = foldl1 ys
      {y',x'} = plus {y,x}
	in  {x', (y':ys')}


-- map specialized to inc
map      []  =^= []
map (x : xs) =^= 
		let x' = inc x
		    xs' = map xs
		in  (x' : xs')


-- Reverse of a list
reverse xs =^= 
		let  {xs_s, xs'}     = length xs
		     {[], ys, xs_s'} = move {xs', [], xs_s} 
		rlet {xs_s', ys}     = length ys'
		in   ys'

-- This function in only partial
--  helper to reverse
move {      x , l,   Z } =^= {x, l, Z}
move {(x : xs), l, S(s)} =^= 
		let {ys, ls, s'} = move {xs,(x:l),s} 
		in  {ys, ls, S(s')}

-- splitAt is identical to the Haskell version
splitAt {  Z ,       l } =^= {[],l}
splitAt {S(s), (l : ls)} =^=
		let {l1, l2} = splitAt {s, ls}
		in  {(l : l1), l2}

-- Finds the head and tail
hdtl (x:xs) =^= {x,xs}

-- Finds the last elements and the rest of the list
last ([x])  =^= {[],x}
last (x:xs) =^= 
	let {xs',l} = last xs
	in  {(x:xs'),l} 


-- If it is called reverse and the N is not equal
--   to the length of the list, I will fail.
length [] =^= {Z,[]}
length (x : xs) =^=
		let {l, xs'} = length xs
		in  {S(l), (x : xs')}

-- append function
append {[],l}      =^= {[], l}
append {(x : xs), l} =^=  
		let {xs', l'} = append {xs, l}
		    {x', x''} = dupEq {x}
		in  {(x' : xs'), (x'' : l')} 

-- The reverse of the append
unAppend x =^=
		rlet x = append x'
		in x'

-- Identical to Haskell replicate function
replicate {S(Z),x} =^= [x]
replicate {S(n),x} =^=
	let {x',x''} = dupEq {x}
	    xs = replicate {n,x'}
	in  (x'':xs)

-- Similar to Haskell intersperse function
intersperse {x,[]}       =^= {x,[]}
intersperse {x,[y]}      =^= {x,[y]}
intersperse {x,(l:list)} =^= 
	let {x',list'} = intersperse {x,list}
	    {x'',xn} = dupEq {x'}
	in  {x'',(l:xn:list')}

-- Identical to Haskell transpose function
transpose []     =^= []
transpose (x:xs) =^=
	let xs' = transpose xs
	in  addToLists {x,xs'}

-- Helper function for transpose
--   Adds empty lists this second input is an empty list, e.g. addToLists {[1,2],[]} = [[1],[2]]
addToLists {[],[]} =^= []
addToLists {(x:xs),[]} =^=
	let ys' = addToLists {xs, []}
	in  (([x]):ys')
addToLists {(x:xs),(y:ys)} =^=
	let ys' = addToLists {xs, ys}
	in  ((x:y):ys')

-- Identical to Haskell subsequences function
subsequences [] =^= [[]]
subsequences (x:xs) =^=
	let xs' = subsequences xs
	in  duplicateAdd {x,xs'}

-- Helper function for subsequences
duplicateAdd {x,[y]} =^= 
	let {y',y''} = dupEq {y}
	in  [y',(x:y'')]
duplicateAdd {x,(y:ys)} =^= 
	let {x',x''} = dupEq {x}
			ys' = duplicateAdd{x',ys}
	    {y',y''} = dupEq {y}
	in  (y':(x'':y''):ys')

-- Divide a list into n lists of size m
divideOf {S(Z),m,xs} =^=
	rlet {m,xs} = length xs'
	in   [xs']
divideOf {S(n),m,xs} =^=
	let {m',m''} = dupEq {m}
			{x,xs'} = splitAt {m', xs}
	    xs'' = divideOf {n,m'',xs'}
	in  (x:xs'')

-- Divide a list into lists of size m
divideSize {m,xs} =^=
	let  {len,xs'} = length xs
	rlet {m,len} = mult {m',n}
	in   divideOf {n,m',xs'}

-- Finds all permutations of a list
--   Does not give the same order as the Haskell version.
permutations [] =^= []
permutations [x] =^= [[x]]
permutations (x:xs) =^=
	let  ys = permutations xs
	     ys' = perms {x,ys}
	rlet ys' = divideSize {m,(y:ys'')}
			 {m,y} = length y'
	in (y':ys'')

-- Helper function for permutations
perms {x,[y]} =^= 
	let z = interleave {x,y}
	in [z]
perms {x, (y:ys)} =^=
	let {x',x''} = dupEq {x}
	    zs = perms {x',ys}
	    z = interleave {x'',y}
	in  (z:zs)

-- Adds x to all possible positions in ys
interleave {x,[]} =^= [[x]]
interleave {x,(y:ys)} =^= 
	let (z:zs) = interleave {x,ys}
			{(x':z'),z''} = dupEq {z}
			(z'':zs') = consToLists {y,(z':z'':zs)}
  in  ((x':z''):zs')

-- Adds x to the front of all lists in ys
consToLists {x,[y]} =^= [(x:y)]
consToLists {x, (y:ys)} =^=
	let {x',x''} = dupEq {x}
	    ys' = consToLists {x',ys}
	in  ((x'':y):ys')

-- Identical to Haskell group function 
--   and not far from the run-length encoding
group [] =^= []
group (x:xs) =^=
	case group xs of
		[] -> [[x]]
		((y:ys):tail) -> 
			case |{x,y}| of
				{x'} ->
					let {x'',y''} = dupEq {x'}
					in  ((x'':y'':ys):tail)
				{x',y'} -> ([x']:(y':ys):tail)

-- Equal to the Haskell tails function
tails [] =^= [[]]
tails (x:xs) =^=
	let {xs',xs''} = dupEq {xs}
	    ys = tails xs'
	in  ((x:xs''):ys)

-- Equal to the Haskell inits function
inits [] =^= [[]]
inits (x:xs) =^=
	let ys = inits xs
			ys' = consToLists {x,ys}
	in  ([]:ys')


---------------------------------------------------------------
---- APPLICATIONS
---------------------------------------------------------------

-- pack :: Eq a => [a] -> [a * N]
pack [] =^= []
pack (c1 : r) =^=
	case pack r of
			[] -> [{c1, S(Z)}]
			({c2, n} : t) ->
					case |{c1,c2}| of
							{c1p, c2p} -> ({c1p, S(Z)} : ({c2p, n} : t))
							{c} -> ({c, S(n)} : t)


pack2 {[],p} =^= {[],p}
pack2 {[h], []} =^= {[],[{h,S(Z)}]}


--unpack [] =^= []
--unpack [{c1, S(Z)}] =^= 
--unpack ({c1p, S(Z)} : ({c2p, n} : t)) =^= 
--unpack ({c, S(n)} : t) =^=

unpack l =^= 
	rlet l = pack l'
	in l'


---------------------------------------------------------------
---- BIDIRECTIONAL
---------------------------------------------------------------

evenOdd Z    =^= Even(Z)
evenOdd S(Z) =^= Odd(S(Z))
evenOdd S(S(x)) =^= 
		case evenOdd x of
		  Even(x') -> Even( S(S(x')) )
		  Odd(x')  -> Odd( S(S(x')) )

mapEvenOdd [] =^= []
mapEvenOdd (x:xs) =^= 
	let eo = evenOdd x
	    eos = mapEvenOdd xs
	in  (eo:eos)

filterH {[],     vs} =^= {[],vs}
filterH {(s:ss), []} =^= {(s:ss), []}
filterH {(s:ss), (v:vs)} =^= 
	case s of
		Odd(s) ->
			let {ss', vs'} = filterH {ss,(v:vs)}
					{s',s''} = dupEq {s}
			in  {(Odd(s'):ss'), (s'':vs')}
		Even(s) ->
			let {ss', vs'} = filterH {ss, vs}
			in  {(Even(s):ss'), (v:vs')}

filter {ss, vs} =^=
	let  eos = mapEvenOdd ss
			 {eos',vs'} = filterH {eos,vs}
	rlet eos' = mapEvenOdd ss'
	in {ss',vs'}


	--case dupFun s of
	--	{s',s''} -> 
	--		let {ss',vs'} = filter {ss,(v:vs)}
	--		in  {(s':ss'),(s'':vs')}
	--	{s'} -> 
	--		let {ss',vs'} = filter {ss,vs}
	--		in  {(s':ss'), (v:vs')}



--makeNil xs = {xs,[]}

--rev {[],ys} =^= {[],ys}
rev {(x:xs), ys} =^= {xs, (x:ys)}

looprev {[], ys} =^= {ys,[]}
looprev {xs, ys} =^= 
	let {xs', ys'} = rev {xs,ys} 
	in looprev {xs',ys'}


revers xs =^= 
	let {ys,[]} = looprev {xs,[]}
	in  ys
