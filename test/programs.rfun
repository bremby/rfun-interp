---------------------------------------------------------------
---- BASIC
---------------------------------------------------------------

-- swap :: a * b -> b * a
swap {x,y} =^= {y,x}

id x =^= x

---------------------------------------------------------------
---- ARITHMETIC
---------------------------------------------------------------

--data N = Z | S(n)

inc Z =^= S(Z)
inc S(np) =^= 
		let npp = inc np 
		in  S(npp)

plus {x,  Z } =^= |{x}|
plus {x,S(u)} =^= 
    let {xp,up} = plus {x,u} 
    in  {xp, S(up)}

minus xy =^=
		rlet xy = plus xy'
		in   xy'

mult {x,  Z } =^= {x,Z}
mult {x,  S(Z) } =^= |{x}|
mult {x,S(S(y))} =^=
		let {x',m} = mult {x,S(y)}
		in  plus {x',m}

-- fib :: N -> N * N
fib Z    =^= {S(Z),S(Z)}
fib S(m) =^= 
		let {x,y} = fib m 
		in plus {y,x}

-- Haskell like combinations
--	fib2 Z    =^= {S(Z),S(Z)}
-- 	fib2 S(m) =^= plus (swap (fib2 m))


---------------------------------------------------------------
---- LIST MANIPULATION
---------------------------------------------------------------

-- scanr specialized to plus
scanr {i,[]}      =^= {i,[]}
scanr {i, (x:xs)} =^= 
  let {i', x'} = plus {i,x}
      {x'',l} = scanr {x', xs}
  in  {i',(x'':l)}

-- scanl specialized to plus
scanl {i,[]}      =^= {i,[]}
scanl {i,[x]}     =^= 
	let {i', x'} = plus {i,x}
	in  {i', [x']}
scanl {i, (x:z:xs)} =^= 
	let {i', (y:ys)} = scanl {i,(z:xs)}
	    {y',x'} = plus {y,x}
	in  {i', (x':y':ys)}

-- map specialized to inc
map [] =^= []
map (x:xs) =^= 
	let x' = inc x
	    xs' = map xs
	in  (x':xs')

reverse xs =^= 
	let  {xs_s,xs'} = length xs
	     {[],ys,xs_s'} = move {xs',[],xs_s} 
	rlet {xs_s',ys} = length ys'
	in   ys'
	
-- This function in only partial
--  helper to reverse
move {x,l,Z}     =^= {x,l,Z}
move {(x:xs),l,S(s)} =^= 
	let {ys,ls,s'} = move {xs,(x:l),s} 
	in  {ys,ls,S(s')}

divideAt {Z,l} =^= {[],l}
divideAt {S(s),(l:ls)} =^=
	let {l1,l2} = divideAt {s,ls}
	in {(l:l1),l2}

ht (x:xs) =^= {x,xs}

last xs =^= 
	let (x:xs') = reverse xs
	    xs'' = reverse xs'
	in  {x,xs''}

-- This is also partial
-- If it is called reverse and the N is not equal
--   to the length of the list, I will fail.
length [] =^= {Z,[]}
length (x:xs) =^=
	let {l,xs'} = length xs
	in  {S(l), (x:xs')}

append {[],l}      =^= {[],l}
append {(x:xs), l} =^= 
	let {xs',l'} = append {xs,l}
	in  case |{x}| of
			{x',x''} -> {(x':xs'), (x'':l')} 

unAppend x =^=
	rlet x = append x'
	in x'


---------------------------------------------------------------
---- APPLICATIONS
---------------------------------------------------------------

-- pack :: Eq a => [a] -> [a * N]
pack [] =^= []
pack (c1 : r) =^=
		let s = pack r in
			case s of
				[] -> ({c1, S(Z)} : [])
				(h : t) ->
					case h of
						{c2, n} ->
							case |{c1,c2}| of
								{c1p, c2p} -> ({c1p, S(Z)} : ({c2p, n} : t))
								{c} -> ({c, S(n)} : t)

