
--data N = Z | S(n)

inc Z =^= S(Z)
inc S(np) =^= 
		let npp = inc np 
		in  S(npp)

-- fib :: N -> N * N
--fib Z    =^= {S(Z),S(Z)}
--fib S(m) =^= 
--		let {x,y} = fib m 
--		in  let z = plus {y,x}
--				in z

plus {x,y} =^= 
    case y of
		Z    -> |{x}|
		S(u) -> let {xp,up} = plus {x,u} in {xp, S(up)}


fib Z    =^= {S(Z),S(Z)}
fib S(m) =^= 
		let {x,y} = fib m 
		in plus {y,x}

-- Haskell like combinations
--	fib Z    =^= {S(Z),S(Z)}
-- 	fib S(m) =^= plus $ swap $ fib m

-- swap :: a * b -> b * a
swap {x,y} =^= {y,x}

-- scanr {}
scanr {i,[]}      =^= {i,[]}
scanr {i, (x:xs)} =^= 
  let {i', x'} = plus {i,x}
      {x'',l} = scanr {x', xs}
  in  {i',(x'':l)}

-- 
scanl {i,[]}      =^= {i,[]}
scanl {i,[x]}     =^= 
	let {i', x'} = plus {i,x}
	in  {i', [x']}
scanl {i, (x:z:xs)} =^= 
	let {i', (y:ys)} = scanl {i,(z:xs)}
	    {y',x'} = plus {y,x}
	in  {i', (x':y':ys)}

map [] =^= []
map (x:xs) =^= 
	let x' = inc x
	    xs' = map xs
	in  (x':xs')

reverse xs =^= 
	let {xs_s,xs'} = length xs
	    {[],ys,xs_s'} = move {xs',[],xs_s}
	in 
		rlet {xs_s',ys} = length ys'
 		in ys'
	
-- This function in only partial
move {x,l,Z}     =^= {x,l,Z}
move {(x:xs),l,S(s)} =^= 
	let {ys,ls,s'} = move {xs,(x:l),s} 
	in  {ys,ls,S(s')}


length [] =^= {Z,[]}
length (x:xs) =^=
	let {l,xs'} = length xs
	in  {S(l), (x:xs')}

-- plus :: N * N -> N * N
-- plus {x,Z} =^= |{x}|
-- plus {x,S(u)} =^= 
--	let {xp,up} = plus {x,u} 
--	in  {xp, S(up)}


-- pack :: Eq a => [a] -> [a * N]
pack [] =^= []
pack (c1 : r) =^=
		let s = pack r in
			case s of
				[] -> ({c1, S(Z)} : [])
				(h : t) ->
					case h of
						{c2, n} ->
							case |{c1,c2}| of
								{c1p, c2p} -> ({c1p, S(Z)} : ({c2p, n} : t))
								{c} -> ({c, S(n)} : t)

